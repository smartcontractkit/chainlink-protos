// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaneSource {
    #[prost(uint64, tag = "1")]
    pub source_chain_selector: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub onramp_address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaneDest {
    #[prost(uint64, tag = "1")]
    pub dest_chain_selector: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub offramp_address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClosedInterval {
    #[prost(uint64, tag = "1")]
    pub min_msg_nr: u64,
    #[prost(uint64, tag = "2")]
    pub max_msg_nr: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixedDestLaneUpdateRequest {
    #[prost(message, optional, tag = "1")]
    pub lane_source: ::core::option::Option<LaneSource>,
    #[prost(message, optional, tag = "2")]
    pub closed_interval: ::core::option::Option<ClosedInterval>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixedDestLaneUpdate {
    #[prost(message, optional, tag = "1")]
    pub lane_source: ::core::option::Option<LaneSource>,
    #[prost(message, optional, tag = "2")]
    pub closed_interval: ::core::option::Option<ClosedInterval>,
    #[prost(bytes = "vec", tag = "3")]
    pub root: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObservationRequest {
    /// could be implied
    #[prost(message, optional, tag = "1")]
    pub lane_dest: ::core::option::Option<LaneDest>,
    #[prost(message, repeated, tag = "2")]
    pub fixed_dest_lane_update_requests: ::prost::alloc::vec::Vec<
        FixedDestLaneUpdateRequest,
    >,
}
/// TODO: For terseness, we might want to split this into two messages down the line:
/// An observation containing only the things that cannot be inferred
/// An observation representing the exact message that is signed by the RMN node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Observation {
    /// could be implied
    #[prost(bytes = "vec", tag = "1")]
    pub rmn_home_contract_config_digest: ::prost::alloc::vec::Vec<u8>,
    /// could be implied
    #[prost(message, optional, tag = "2")]
    pub lane_dest: ::core::option::Option<LaneDest>,
    #[prost(message, repeated, tag = "3")]
    pub fixed_dest_lane_updates: ::prost::alloc::vec::Vec<FixedDestLaneUpdate>,
    #[prost(uint64, tag = "4")]
    pub timestamp: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedObservation {
    #[prost(message, optional, tag = "1")]
    pub observation: ::core::option::Option<Observation>,
    /// sign(sha256("chainlink ccip 1.6 rmn observation"|sha256(observation)))
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributedSignedObservation {
    #[prost(message, optional, tag = "1")]
    pub signed_observation: ::core::option::Option<SignedObservation>,
    #[prost(uint32, tag = "2")]
    pub signer_node_index: u32,
}
/// Signed along with the report
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportContext {
    #[prost(uint64, tag = "1")]
    pub evm_dest_chain_id: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub rmn_remote_contract_address: ::prost::alloc::vec::Vec<u8>,
    /// can lag behind home chain to support blue/green
    #[prost(bytes = "vec", tag = "3")]
    pub rmn_home_contract_config_digest: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub lane_dest: ::core::option::Option<LaneDest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportSignatureRequest {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<ReportContext>,
    #[prost(message, repeated, tag = "2")]
    pub attributed_signed_observations: ::prost::alloc::vec::Vec<
        AttributedSignedObservation,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportSignature {
    /// bytes signed_hash = 1; // needless since we have a request_id
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<EcdsaSignature>,
}
/// CCIP -> RMN
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(oneof = "request::Request", tags = "2, 3")]
    pub request: ::core::option::Option<request::Request>,
}
/// Nested message and enum types in `Request`.
pub mod request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "2")]
        ObservationRequest(super::ObservationRequest),
        #[prost(message, tag = "3")]
        ReportSignatureRequest(super::ReportSignatureRequest),
    }
}
/// RMN -> CCIP
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(oneof = "response::Response", tags = "2, 3")]
    pub response: ::core::option::Option<response::Response>,
}
/// Nested message and enum types in `Response`.
pub mod response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "2")]
        SignedObservation(super::SignedObservation),
        #[prost(message, tag = "3")]
        ReportSignature(super::ReportSignature),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EcdsaSignature {
    #[prost(bytes = "vec", tag = "1")]
    pub r: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub s: ::prost::alloc::vec::Vec<u8>,
}
/// To be sent by the OCR leader in a "BuildingReports" round.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportingPluginQuery {
    #[prost(message, repeated, tag = "1")]
    pub fixed_dest_lane_updates: ::prost::alloc::vec::Vec<FixedDestLaneUpdate>,
    #[prost(message, repeated, tag = "2")]
    pub ecdsa_signatures: ::prost::alloc::vec::Vec<EcdsaSignature>,
}
